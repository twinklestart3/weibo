【微博表】
rowkey：userid+发布微博的时间
唯一：userid+时间戳
散列：不同用户之间散列(均匀分布在不同region)--通过userid随机生成实现散列
集中：相同用户内部集中(相同用户的数据集中在同一分区)--前缀userid相同即可实现相同用户集中
每个region内部数据有序。
查找：根据rowkey前缀先找到分区，再在该分区内查找具体数据。

列族：只需要一个，cf1
		列名：title、content、image、time、userid
		列值：



【用户关系表】
rowkey：userid
列族：①cf1：关注用户
		把关注用户的id作为列名，列值可以为任何值(hbase是按列存储的，一个列族下包括的列的数量对性能没有任何影响)
      ②cf2：粉丝用户
		把粉丝用户的id作为列名，列值可以为任何值




【用户接收微博列表表】
方式一：
rowkey：userid
列族：只需要一个，cf1：{VERSIONS=100}
		列名：也只有一个且是固定的(weibo)，保存了最新100条微博(因为定义了VERSIONS=100)，最新的微博覆盖最旧的微博，类似长度为100的队列
		列值：就是微博的rowkey
		版本：微博发布时间的时间戳，可以保证最新的100条微博按序排序(但有可能覆盖相同时间戳的微博，不同用户可能同一时间戳发布微博，可以在业务层解决相同时间戳的问题)


方式二：
rowkey：userid
列族：只需要一个，cf1
		列名：把关注用户的id作为列名，关注多少个人，就有多少个列(每个列内部有序，不同列之间无序，因此需要二次排序)
		列值：把关注用户发布的微博的rowkey作为列值。
		版本：{VERSIONS=100}
		
方式三：
rowkey：userid + (Long.max_value - 发布微博的时间)
列族：只需要一个，cf1
		列名：发布微博的rowkey